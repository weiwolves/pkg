// Code generated by codegen. DO NOT EDIT.
// +build csall db

package storage

import (
	"context"
	"fmt"
	"io"
	"time"

	"github.com/corestoreio/errors"
	"github.com/weiwolves/pkg/sql/ddl"
	"github.com/weiwolves/pkg/sql/dml"
	"github.com/weiwolves/pkg/storage/null"
)

const (
	TableNameCoreConfiguration = "core_configuration"
)

// NewTables returns a goified version of the MySQL/MariaDB table schema for the
// tables:  core_configuration Auto generated by dmlgen.
func NewTables(ctx context.Context, opts ...ddl.TableOption) (tm *ddl.Tables, err error) {
	if tm, err = ddl.NewTables(
		append(opts, ddl.WithCreateTable(ctx, TableNameCoreConfiguration, ""))...,
	); err != nil {
		return nil, errors.WithStack(err)
	}
	return tm, nil
}

// CoreConfiguration  represents a single row for DB table  core_configuration .
// Auto generated.
type CoreConfiguration struct {
	ID        uint64      `max_len:"20"` // id bigint(20) unsigned NOT NULL PRI  auto_increment "ID"
	Scope     string      `max_len:"8"`  // scope varchar(8) NOT NULL MUL DEFAULT ''default''  "Scope"
	ScopeID   int32       `max_len:"10"` // scope_id int(11) NOT NULL  DEFAULT '0'  "Scope ID"
	Expires   null.Time   // expires datetime NULL  DEFAULT 'NULL'  "Value expiration time"
	Path      string      `max_len:"255"`   // path varchar(255) NOT NULL    "Path"
	Value     null.String `max_len:"65535"` // value text NULL  DEFAULT 'NULL'  "Value"
	VersionTs time.Time   // version_ts timestamp(6) NOT NULL   INVISIBLE "Timestamp Start Versioning"
	VersionTe time.Time   // version_te timestamp(6) NOT NULL PRI  INVISIBLE "Timestamp End Versioning"
}

// WriteTo implements io.WriterTo and writes the field names and their values to
// w. This is especially useful for debugging or or generating a hash of the
// struct.
func (e *CoreConfiguration) WriteTo(w io.Writer) (n int64, err error) {
	// for now this printing is good enough. If you need better swap out with your code.
	n2, err := fmt.Fprint(w,
		"id:", e.ID, "\n",
		"scope:", e.Scope, "\n",
		"scope_id:", e.ScopeID, "\n",
		"expires:", e.Expires, "\n",
		"path:", e.Path, "\n",
		"value:", e.Value, "\n",
		"version_ts:", e.VersionTs, "\n",
		"version_te:", e.VersionTe, "\n",
	)
	return int64(n2), err
}

// AssignLastInsertID updates the increment ID field with the last inserted ID
// from an INSERT operation. Implements dml.InsertIDAssigner. Auto generated.
func (e *CoreConfiguration) AssignLastInsertID(id int64) {
	e.ID = uint64(id)
}

// MapColumns implements interface ColumnMapper only partially. Auto generated.
func (e *CoreConfiguration) MapColumns(cm *dml.ColumnMap) error {
	if cm.Mode() == dml.ColumnMapEntityReadAll {
		return cm.Uint64(&e.ID).String(&e.Scope).Int32(&e.ScopeID).NullTime(&e.Expires).String(&e.Path).NullString(&e.Value).Time(&e.VersionTs).Time(&e.VersionTe).Err()
	}
	for cm.Next() {
		switch c := cm.Column(); c {
		case "id":
			cm.Uint64(&e.ID)
		case "scope":
			cm.String(&e.Scope)
		case "scope_id":
			cm.Int32(&e.ScopeID)
		case "expires":
			cm.NullTime(&e.Expires)
		case "path":
			cm.String(&e.Path)
		case "value":
			cm.NullString(&e.Value)
		case "version_ts":
			cm.Time(&e.VersionTs)
		case "version_te":
			cm.Time(&e.VersionTe)
		default:
			return errors.NotFound.Newf("[storage] CoreConfiguration Column %q not found", c)
		}
	}
	return errors.WithStack(cm.Err())
}

// CoreConfigurationCollection represents a collection type for DB table
// core_configuration
// Not thread safe. Auto generated.
type CoreConfigurationCollection struct {
	Data             []*CoreConfiguration                   `json:"data,omitempty"`
	BeforeMapColumns func(uint64, *CoreConfiguration) error `json:"-"`
	AfterMapColumns  func(uint64, *CoreConfiguration) error `json:"-"`
}

// NewCoreConfigurationCollection  creates a new initialized collection. Auto
// generated.
func NewCoreConfigurationCollection() *CoreConfigurationCollection {
	return &CoreConfigurationCollection{
		Data: make([]*CoreConfiguration, 0, 5),
	}
}

// AssignLastInsertID traverses through the slice and sets a decrementing new ID
// to each entity.
func (cc *CoreConfigurationCollection) AssignLastInsertID(id int64) {
	var j int64
	for i := len(cc.Data) - 1; i >= 0; i-- {
		cc.Data[i].AssignLastInsertID(id - j)
		j++
	}
}

func (cc *CoreConfigurationCollection) scanColumns(cm *dml.ColumnMap, e *CoreConfiguration, idx uint64) error {
	if cc.BeforeMapColumns != nil {
		if err := cc.BeforeMapColumns(idx, e); err != nil {
			return errors.WithStack(err)
		}
	}
	if err := e.MapColumns(cm); err != nil {
		return errors.WithStack(err)
	}
	if cc.AfterMapColumns != nil {
		if err := cc.AfterMapColumns(idx, e); err != nil {
			return errors.WithStack(err)
		}
	}
	return nil
}

// MapColumns implements dml.ColumnMapper interface. Auto generated.
func (cc *CoreConfigurationCollection) MapColumns(cm *dml.ColumnMap) error {
	switch m := cm.Mode(); m {
	case dml.ColumnMapEntityReadAll, dml.ColumnMapEntityReadSet:
		for i, e := range cc.Data {
			if err := cc.scanColumns(cm, e, uint64(i)); err != nil {
				return errors.WithStack(err)
			}
		}
	case dml.ColumnMapScan:
		if cm.Count == 0 {
			cc.Data = cc.Data[:0]
		}
		e := new(CoreConfiguration)
		if err := cc.scanColumns(cm, e, cm.Count); err != nil {
			return errors.WithStack(err)
		}
		cc.Data = append(cc.Data, e)
	case dml.ColumnMapCollectionReadSet:
		for cm.Next() {
			switch c := cm.Column(); c {
			case "id":
				cm = cm.Uint64s(cc.IDs()...)
			default:
				return errors.NotFound.Newf("[storage] CoreConfigurationCollection Column %q not found", c)
			}
		} // end for cm.Next

	default:
		return errors.NotSupported.Newf("[storage] Unknown Mode: %q", string(m))
	}
	return cm.Err()
}

// IDs returns a slice with the data or appends it to a slice.
// Auto generated.
func (cc *CoreConfigurationCollection) IDs(ret ...uint64) []uint64 {
	if ret == nil {
		ret = make([]uint64, 0, len(cc.Data))
	}
	for _, e := range cc.Data {
		ret = append(ret, e.ID)
	}
	return ret
}

// WriteTo implements io.WriterTo and writes the field names and their values to
// w. This is especially useful for debugging or or generating a hash of the
// struct.
func (cc *CoreConfigurationCollection) WriteTo(w io.Writer) (n int64, err error) {
	for i, d := range cc.Data {
		n2, err := d.WriteTo(w)
		if err != nil {
			return 0, errors.Wrapf(err, "[storage] WriteTo failed at index %d", i)
		}
		n += n2
	}
	return n, nil
}
